{"version":3,"sources":["../../../src/common/framework/test_group.ts"],"names":["allowedTestNameCharacters","extractPublicParams","paramsEquals","checkPublicParamType","assert","validNames","RegExp","TestGroup","constructor","fixture","Set","iterate","log","test","tests","checkName","name","decodeURIComponent","seen","has","add","indexOf","replace","TestBuilder","push","fn","testFn","params","specs","cases","Array","from","spec","publicParams","v","Object","values","some","x","JSON","stringify","rec","undefined","RunCaseSpecific","recorder","id","run","debug","res","record","start","inst","init","finalize","ex","threw","finish","injectResult","result","assign"],"mappings":"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","sourcesContent":["import { allowedTestNameCharacters } from './allowed_characters.js';\nimport { Fixture } from './fixture.js';\nimport { TestCaseID } from './id.js';\nimport { LiveTestCaseResult, TestCaseRecorder, TestSpecRecorder } from './logger.js';\nimport { ParamSpec, ParamSpecIterable, extractPublicParams, paramsEquals } from './params_utils.js';\nimport { checkPublicParamType } from './url_query.js';\nimport { assert } from './util/util.js';\n\nexport interface RunCase {\n  readonly id: TestCaseID;\n  run(debug?: boolean): Promise<LiveTestCaseResult>;\n  injectResult(result: LiveTestCaseResult): void;\n}\n\nexport interface RunCaseIterable {\n  iterate(rec: TestSpecRecorder): Iterable<RunCase>;\n}\n\ntype FixtureClass<F extends Fixture> = new (log: TestCaseRecorder, params: ParamSpec) => F;\ntype TestFn<F extends Fixture, P extends {}> = (t: F & { params: P }) => Promise<void> | void;\n\nconst validNames = new RegExp('^[' + allowedTestNameCharacters + ']+$');\n\nexport class TestGroup<F extends Fixture> implements RunCaseIterable {\n  private fixture: FixtureClass<F>;\n  private seen: Set<string> = new Set();\n  private tests: Array<TestBuilder<F, never>> = [];\n\n  constructor(fixture: FixtureClass<F>) {\n    this.fixture = fixture;\n  }\n\n  *iterate(log: TestSpecRecorder): Iterable<RunCase> {\n    for (const test of this.tests) {\n      yield* test.iterate(log);\n    }\n  }\n\n  private checkName(name: string): void {\n    assert(validNames.test(name), `Invalid test name ${name}; must match [${validNames}]+`);\n    assert(\n      // Shouldn't happen due to the rule above. Just makes sure that treated\n      // unencoded strings as encoded strings is OK.\n      name === decodeURIComponent(name),\n      `Not decodeURIComponent-idempotent: ${name} !== ${decodeURIComponent(name)}`\n    );\n    assert(!this.seen.has(name), `Duplicate test name: ${name}`);\n\n    this.seen.add(name);\n  }\n\n  // TODO: This could take a fixture, too, to override the one for the group.\n  test(name: string): TestBuilderWithName<F, never> {\n    // Replace spaces with underscores for readability.\n    assert(name.indexOf('_') === -1, 'Invalid test name ${name}: contains underscore (use space)');\n    name = name.replace(/ /g, '_');\n\n    this.checkName(name);\n\n    const test = new TestBuilder<F, never>(name, this.fixture);\n    this.tests.push(test);\n    return test;\n  }\n}\n\ninterface TestBuilderWithName<F extends Fixture, P extends {}> extends TestBuilderWithParams<F, P> {\n  params<NewP extends {}>(specs: Iterable<NewP>): TestBuilderWithParams<F, NewP>;\n}\n\ninterface TestBuilderWithParams<F extends Fixture, P extends {}> {\n  fn(fn: TestFn<F, P>): void;\n}\n\nclass TestBuilder<F extends Fixture, P extends {}> {\n  private readonly name: string;\n  private readonly fixture: FixtureClass<F>;\n  private testFn: TestFn<F, P> | undefined;\n  private cases: ParamSpecIterable | null = null;\n\n  constructor(name: string, fixture: FixtureClass<F>) {\n    this.name = name;\n    this.fixture = fixture;\n  }\n\n  fn(fn: TestFn<F, P>): void {\n    this.testFn = fn;\n  }\n\n  params<NewP extends {}>(specs: Iterable<NewP>): TestBuilderWithParams<F, NewP> {\n    assert(this.cases === null, 'test case is already parameterized');\n    const cases = Array.from(specs);\n    const seen: ParamSpec[] = [];\n    // This is n^2.\n    for (const spec of cases) {\n      const publicParams = extractPublicParams(spec);\n\n      // Check type of public params: can only be (currently):\n      // number, string, boolean, undefined, number[]\n      for (const v of Object.values(publicParams)) {\n        checkPublicParamType(v);\n      }\n\n      assert(\n        !seen.some(x => paramsEquals(x, publicParams)),\n        'Duplicate test case params: ' + JSON.stringify(publicParams)\n      );\n      seen.push(publicParams);\n    }\n    this.cases = cases;\n\n    return (this as unknown) as TestBuilderWithParams<F, NewP>;\n  }\n\n  *iterate(rec: TestSpecRecorder): IterableIterator<RunCase> {\n    assert(this.testFn !== undefined, 'internal error');\n    for (const params of this.cases || [null]) {\n      yield new RunCaseSpecific(rec, this.name, params, this.fixture, this.testFn);\n    }\n  }\n}\n\nclass RunCaseSpecific<F extends Fixture> implements RunCase {\n  readonly id: TestCaseID;\n  private readonly params: ParamSpec | null;\n  private readonly recorder: TestSpecRecorder;\n  private readonly fixture: FixtureClass<F>;\n  private readonly fn: TestFn<F, never>;\n\n  constructor(\n    recorder: TestSpecRecorder,\n    test: string,\n    params: ParamSpec | null,\n    fixture: FixtureClass<F>,\n    fn: TestFn<F, never>\n  ) {\n    this.id = { test, params: params ? extractPublicParams(params) : null };\n    this.params = params;\n    this.recorder = recorder;\n    this.fixture = fixture;\n    this.fn = fn;\n  }\n\n  async run(debug: boolean): Promise<LiveTestCaseResult> {\n    const [rec, res] = this.recorder.record(this.id.test, this.id.params);\n    rec.start(debug);\n\n    try {\n      const inst = new this.fixture(rec, this.params || {});\n\n      try {\n        await inst.init();\n        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n        await this.fn(inst as any);\n      } finally {\n        // Runs as long as constructor succeeded, even if initialization or the test failed.\n        await inst.finalize();\n      }\n    } catch (ex) {\n      // There was an exception from constructor, init, test, or finalize.\n      // An error from init or test may have been a SkipTestCase.\n      // An error from finalize may have been an eventualAsyncExpectation failure\n      // or unexpected validation/OOM error from the GPUDevice.\n      rec.threw(ex);\n    }\n\n    rec.finish();\n    return res;\n  }\n\n  injectResult(result: LiveTestCaseResult): void {\n    const [, res] = this.recorder.record(this.id.test, this.id.params);\n    Object.assign(res, result);\n  }\n}\n"],"file":"test_group.js"}